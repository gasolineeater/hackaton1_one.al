name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest

    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_DATABASE: one_albania_test_db
        ports:
          - 3306:3306
        options: --health-cmd="mysqladmin ping" --health-interval=10s --health-timeout=5s --health-retries=3

    steps:
      - uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: 'api/package-lock.json'

      - name: Install dependencies
        working-directory: ./api
        run: npm ci

      - name: Run linter
        working-directory: ./api
        run: npm run lint

      - name: Run tests
        working-directory: ./api
        run: npm test
        env:
          NODE_ENV: test
          DB_HOST: localhost
          DB_PORT: 3306
          DB_NAME: one_albania_test_db
          DB_USER: root
          DB_PASSWORD: root
          JWT_SECRET: test_jwt_secret_key_for_testing_purposes_only

      - name: Generate test coverage report
        working-directory: ./api
        run: npm run test:coverage

      - name: Upload test coverage
        uses: actions/upload-artifact@v3
        with:
          name: coverage-report
          path: api/coverage/

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: test

    steps:
      - uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        working-directory: ./api
        run: npm ci

      - name: Run npm audit
        working-directory: ./api
        run: npm audit --audit-level=high

      - name: Run OWASP Dependency-Check
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: 'ONE Albania API'
          path: 'api'
          format: 'HTML'
          out: 'reports'
          args: >
            --suppression suppression.xml
            --failOnCVSS 7
            --enableRetired

      - name: Upload security report
        uses: actions/upload-artifact@v3
        with:
          name: security-report
          path: reports/

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [test, security-scan]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')

    steps:
      - uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: 'api/package-lock.json'

      - name: Install dependencies
        working-directory: ./api
        run: npm ci --production

      - name: Generate API documentation
        working-directory: ./api
        run: npm run docs

      - name: Create .env file
        working-directory: ./api
        run: |
          if [[ $GITHUB_REF == 'refs/heads/main' ]]; then
            echo "Creating production .env file"
            echo "NODE_ENV=production" > .env
          else
            echo "Creating staging .env file"
            echo "NODE_ENV=staging" > .env
          fi
          echo "PORT=${{ secrets.PORT }}" >> .env
          echo "ALLOWED_ORIGINS=${{ secrets.ALLOWED_ORIGINS }}" >> .env
          echo "DB_HOST=${{ secrets.DB_HOST }}" >> .env
          echo "DB_PORT=${{ secrets.DB_PORT }}" >> .env
          echo "DB_NAME=${{ secrets.DB_NAME }}" >> .env
          echo "DB_USER=${{ secrets.DB_USER }}" >> .env
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> .env
          echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" >> .env
          echo "JWT_ACCESS_EXPIRATION=${{ secrets.JWT_ACCESS_EXPIRATION }}" >> .env
          echo "JWT_REFRESH_EXPIRATION=${{ secrets.JWT_REFRESH_EXPIRATION }}" >> .env
          echo "GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}" >> .env

      - name: Create deployment package
        run: |
          mkdir -p deployment
          cp -r api deployment/
          cp docker-compose.yml deployment/
          cp Dockerfile deployment/
          tar -czf deployment.tar.gz deployment/

      - name: Upload deployment package
        uses: actions/upload-artifact@v3
        with:
          name: deployment-package
          path: deployment.tar.gz

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/develop'
    environment: staging

    steps:
      - name: Download deployment package
        uses: actions/download-artifact@v3
        with:
          name: deployment-package

      - name: Extract deployment package
        run: tar -xzf deployment.tar.gz

      - name: Deploy to staging server
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USERNAME }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          source: "deployment/*"
          target: "/var/www/onealbania-staging"
          strip_components: 1

      - name: Run database migrations and restart services
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USERNAME }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          script: |
            cd /var/www/onealbania-staging

            # Backup the database before migrations
            echo "Creating database backup..."
            docker-compose exec -T db mysqldump -u root -p${{ secrets.DB_ROOT_PASSWORD }} ${{ secrets.DB_NAME }} > backup-$(date +%Y%m%d%H%M%S).sql

            # Stop the services
            docker-compose down

            # Start the database first
            docker-compose up -d db

            # Wait for database to be ready
            echo "Waiting for database to be ready..."
            sleep 30

            # Run migrations
            echo "Running database migrations..."
            docker-compose run --rm api node scripts/initDb.js

            # Start all services
            docker-compose up -d

            # Clean up unused resources
            docker system prune -af

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
      - name: Download deployment package
        uses: actions/download-artifact@v3
        with:
          name: deployment-package

      - name: Extract deployment package
        run: tar -xzf deployment.tar.gz

      - name: Deploy to production server
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USERNAME }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          source: "deployment/*"
          target: "/var/www/onealbania-production"
          strip_components: 1

      - name: Run database migrations and restart services
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USERNAME }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          script: |
            cd /var/www/onealbania-production

            # Backup the database before migrations
            echo "Creating database backup..."
            docker-compose exec -T db mysqldump -u root -p${{ secrets.DB_ROOT_PASSWORD }} ${{ secrets.DB_NAME }} > backup-$(date +%Y%m%d%H%M%S).sql

            # Stop the services
            docker-compose down

            # Start the database first
            docker-compose up -d db

            # Wait for database to be ready
            echo "Waiting for database to be ready..."
            sleep 30

            # Run migrations
            echo "Running database migrations..."
            docker-compose run --rm api node scripts/initDb.js

            # Start all services
            docker-compose up -d

            # Clean up unused resources
            docker system prune -af
